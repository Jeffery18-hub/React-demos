{"ast":null,"code":"export const isWinner = (gameBoard, currentMove, currentPlayer) => {\n  // gameBoard is an array of 16 elements, and pass by reference\n  let board = [...gameBoard]; // copy of the array of game state\n  board[currentMove] = currentPlayer;\n  const winLines = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15], [0, 4, 8, 12], [1, 5, 9, 13], [2, 6, 10, 14], [3, 7, 11, 15], [0, 5, 10, 15], [3, 6, 9, 12]];\n  for (let i = 0; i < winLines.length; i++) {\n    const [c1, c2, c3, c4] = winLines[i];\n    if (board[c1] > 0 && board[c1] === board[c2] && board[c2] === board[c3] && board[c3] === board[c4]) {\n      return true;\n    }\n  }\n  return false;\n};\nexport const isDraw = (gameBoard, currentMove, currentPlayer) => {\n  let board = [...gameBoard]; // copy of the array of game state\n  board[currentMove] = currentPlayer;\n  return board.every(value => value > 0);\n};\nconst getRndMove = gameBoard => {\n  let suggestMoves = [];\n  for (let i = 0; i < gameBoard.length; i++) {\n    if (gameBoard[i] === 0) {\n      suggestMoves.push(i);\n    }\n  }\n  let suggestMove = suggestMoves[Math.floor(Math.random() * suggestMoves.length)];\n  return suggestMove;\n};\nconst getPosition = (gameBoard, moveChecks) => {\n  for (let check = 0; check < moveChecks.length; check++) {\n    for (let i = 0; i < moveChecks[check].max; i += moveChecks[check].step) {\n      let series = gameBoard[i + moveChecks[check].indices[0]].toString() + gameBoard[i + moveChecks[check].indices[1]].toString() + gameBoard[i + moveChecks[check].indices[2]].toString() + gameBoard[i + moveChecks[check].indices[3]].toString();\n      switch (series) {\n        case \"1110\":\n        case \"2220\":\n          return i + moveChecks[check].indices[3];\n        case \"1101\":\n        case \"2202\":\n          return i + moveChecks[check].indices[2];\n        case \"1011\":\n        case \"2022\":\n          return i + moveChecks[check].indices[1];\n        case \"0111\":\n        case \"0222\":\n          return i + moveChecks[check].indices[0];\n        default:\n      }\n    }\n  }\n  return -1;\n};\nexport const getSuggestMove = gameBoard => {\n  let moveChecks = [\n  // store the json object of the move\n  {\n    // vertical\n    indices: [0, 4, 8, 12],\n    // [1,5,9,13] [2,6,10,14] [3,7,11,15]\n    max: 4,\n    step: 1\n  }, {\n    // horizontal\n    indices: [0, 1, 2, 3],\n    // [4,5,6,7] [8,9,10,11] [12,13,14,15]\n    max: 16,\n    step: 4\n  }, {\n    // diagonal\n    indices: [0, 5, 10, 15],\n    max: 16,\n    step: 16\n  }, {\n    // diagonal\n    indices: [3, 6, 9, 12],\n    max: 16,\n    step: 16\n  }];\n  let suggestMove = getPosition(gameBoard, moveChecks);\n  if (suggestMove > -1) return suggestMove;\n  return getRndMove(gameBoard);\n};","map":{"version":3,"names":["isWinner","gameBoard","currentMove","currentPlayer","board","winLines","i","length","c1","c2","c3","c4","isDraw","every","value","getRndMove","suggestMoves","push","suggestMove","Math","floor","random","getPosition","moveChecks","check","max","step","series","indices","toString","getSuggestMove"],"sources":["/Users/tacodaddy/learnReact/connect-game/src/helper.js"],"sourcesContent":["export const isWinner = (gameBoard,currentMove, currentPlayer)=>{ // gameBoard is an array of 16 elements, and pass by reference\n    let board = [...gameBoard]; // copy of the array of game state\n    board[currentMove] = currentPlayer;\n    \n    const winLines = [\n        [0,1,2,3],\n        [4,5,6,7],\n        [8,9,10,11],\n        [12,13,14,15],\n        [0,4,8,12],\n        [1,5,9,13],\n        [2,6,10,14],\n        [3,7,11,15],\n        [0,5,10,15],\n        [3,6,9,12]\n    ];\n    \n    for (let i = 0; i < winLines.length; i++) {\n        const [c1,c2,c3,c4] = winLines[i];\n        if (board[c1]>0 &&\n            board[c1] === board[c2] && \n            board[c2] === board[c3] && \n            board[c3] === board[c4] ) {\n            return true;\n        }\n    }\n    return false;\n\n}\n\nexport const isDraw = (gameBoard, currentMove,currentPlayer) => {\n    let board = [...gameBoard]; // copy of the array of game state\n    board[currentMove] = currentPlayer;\n    return board.every((value) => value > 0);\n\n}\n\n\nconst getRndMove = (gameBoard) => {\n    let suggestMoves = [];\n    for (let i = 0; i < gameBoard.length; i++) {\n        if (gameBoard[i] === 0) {\n            suggestMoves.push(i);\n        }\n    }\n    let suggestMove = suggestMoves[Math.floor(Math.random() * suggestMoves.length)];\n\n    return suggestMove;\n}\n\nconst getPosition = (gameBoard, moveChecks) => {\n    for (let check = 0; check < moveChecks.length; check++) {\n        for(let i= 0; i < moveChecks[check].max; i+= moveChecks[check].step) {\n            let series = gameBoard[i+ moveChecks[check].indices[0]].toString() + \n            gameBoard[i+ moveChecks[check].indices[1]].toString() +\n            gameBoard[i+ moveChecks[check].indices[2]].toString() +\n            gameBoard[i+ moveChecks[check].indices[3]].toString();\n\n            switch (series) {\n                case \"1110\":\n                case \"2220\":\n                    return i+ moveChecks[check].indices[3];\n                case \"1101\":\n                case \"2202\":\n                    return i+ moveChecks[check].indices[2];\n                case \"1011\":\n                case \"2022\":\n                    return i+ moveChecks[check].indices[1];\n                case \"0111\":\n                case \"0222\":\n                    return i+ moveChecks[check].indices[0];\n                default:\n            }\n        }\n    }\n    return -1;\n}\n\n\n\nexport const getSuggestMove = (gameBoard) => {\n    let moveChecks = [\n        // store the json object of the move\n        {// vertical\n            indices: [0, 4, 8, 12], // [1,5,9,13] [2,6,10,14] [3,7,11,15]\n            max:4,\n            step:1,\n        },\n        {// horizontal\n            indices: [0, 1, 2, 3], // [4,5,6,7] [8,9,10,11] [12,13,14,15]\n            max:16,\n            step:4,\n        },\n        {// diagonal\n            indices: [0, 5, 10, 15],\n            max:16,\n            step:16,\n        },\n        {// diagonal\n            indices: [3, 6, 9, 12],\n            max:16,\n            step:16,\n        },\n    ];\n\n    let suggestMove = getPosition(gameBoard, moveChecks);\n    if (suggestMove > -1) return suggestMove;\n    return getRndMove(gameBoard);\n    \n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}